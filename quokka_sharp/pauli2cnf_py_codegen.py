from sympy.logic.boolalg import *
from sympy.logic import simplify_logic
from sympy import symbols 

r    = symbols('r')
R    = symbols('R')

u    = symbols('u')
U    = symbols('U')
d    = symbols('d')
D    = symbols('D')

u1    = symbols('u1')
u2    = symbols('u2')


c = 0
t = 1
k = 2

x = [0,0,0]
z = [0,0,0]
x[k] = symbols("x[k]")
x[c] = symbols("x[c]")
x[t] = symbols("x[t]")
z[k] = symbols("z[k]")
z[c] = symbols("z[c]")
z[t] = symbols("z[t]")

X    = symbols('X')
Z    = symbols('Z')

def strstrip(item1):
    return item1.lstrip(' ()~')

def to_py(func, prefix="", simplify=True, force=True):
    print(prefix+"        # "+str(func))
    s = str(to_cnf(func, simplify=simplify, force=force))
    for a in s.split("&"):
        print(prefix+"        cnf.add_clause([", end="")
        l = a.split("|")
        l.sort(key=strstrip)
        for x in l:
            b = x.strip(' ()')
            if b.startswith('~'):
                b = b.replace('~', '-')
            else:
                b = " "+ b
            print(b, end="")
            if x != l[-1]:
                print(", ", end="")
        print("])")

# TODO: why we add weight of -1 to R and 1 to -R?
def add_sign(func, prefix = ""):
    print(prefix+f"        # adding sign if {func}")
    print(prefix+"        R = cnf.add_var()")
    print(prefix+"        cnf.vars.RVar.append(R)")
    print(prefix+"        if cnf.weighted: ")
    print(prefix+"            cnf.add_weight(R, -1)")
    print(prefix+"            cnf.add_weight(-R, 1)")
    to_py(	                  Equivalent(R, func), prefix+"    ")
    print(prefix+"        else: ")
    print(prefix+"            r = cnf.vars.r")
    print(prefix+"            cnf.vars.r = R")
    to_py(	                  Equivalent(R, r ^ func), prefix+"    ")

def add_sqrt_half(func, prefix = ""):
    print(prefix+f"        # adding sqrt_half if {func}")
    print(prefix+"        U = cnf.add_var()")
    print(prefix+"        cnf.vars.UVar.append(U)")
    print(prefix+"        if cnf.weighted: ")
    print(prefix+"            cnf.add_weight(U, str(Decimal(1/2).sqrt()))")
    print(prefix+"            cnf.add_weight(-U, 1)")
    to_py(	                  Equivalent(U, func), prefix+"    ")
    print(prefix+"        else: ")
    print(prefix+"            cnf.power_two_normalisation += 0.5 ")
    print(prefix+"            u = cnf.vars.u")
    print(prefix+"            cnf.vars.u = U")
    to_py(	                  Equivalent(U, u ^ ~func), prefix+"    ")
    print()
    print(prefix+"            D = cnf.add_var()")
    print(prefix+"            cnf.add_clause([D, cnf.add_var()])")
    to_py(	                  Equivalent(D, u & ~U), prefix+"    ")

def main():

    print("# This code was generated by pauli2cnf_py_codegen.py.")
    print("import math")
    print("from decimal import Decimal, getcontext")
    print("getcontext().prec = 32")
    print()
    print("class pauli2cnf:")
    print('''    \"\"\"
    This class contains the functions to convert a quantum circuit to CNF clauses in the Pauli basis.
    \"\"\"''')
    print()

    # H:
    print("    def H2CNF(cnf, k):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    add_sign(x[k] & z[k])
    print()
    print("        x[k], z[k] = z[k], x[k]")
    print()

    # X:
    print("    def X2CNF(cnf, k):")
    print("        z = cnf.vars.z")
    print()
    add_sign(z[k])
    print()

    # Y:
    print("    def Y2CNF(cnf, k):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    add_sign(x[k] ^ z[k])
    print()

    # Z:
    print("    def Z2CNF(cnf, k):")
    print("        x = cnf.vars.x")
    print()
    add_sign(x[k])
    print()

    # S:
    print("    def S2CNF(cnf, k):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        Z = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Z)")
    to_py(	       Equivalent(Z, x[k] ^ z[k]))
    print()
    add_sign(x[k] & z[k])
    print()
    print("        cnf.vars.z[k] = Z")
    print()

    # Sdg:
    print("    def Sdg2CNF(cnf, k):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        Z = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Z)")
    to_py(	       Equivalent(Z, x[k] ^ z[k]))
    print()
    add_sign(x[k] & ~z[k])
    print()    
    print("        cnf.vars.z[k] = Z")
    print()
    
    # T_r = tg >> Equivalent(Rk, x[k] & z[k] & ~Zk)
    # Tdg_r = tdg >> Equivalent(Rk, x[k] & ~z[k] & Zk)
    # T_x = (tg | tdg) >> Equivalent(Xk, x[k])
    # T_z = (tg | tdg) >> Equivalent(Zk, z[k]) | x[k]
    # T_u = (tg | tdg) >> Equivalent(Uk, x[k])

    # T:
    print("    def T2CNF(cnf, k):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()   
    print("        Z = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Z)")
    to_py(	       x[k] | Equivalent(Z, z[k]))
    print()   
    add_sqrt_half(x[k])
    print()
    add_sign(x[k] & z[k] & ~Z)
    print()
    print("        cnf.vars.z[k] = Z")
    print()

    # Tdag:
    print("    def Tdg2CNF(cnf, k):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        Z = cnf.add_var()")  
    print("        cnf.vars.ZVar.append(Z)")
    to_py(	       x[k] | Equivalent(Z, z[k]))
    print()   
    add_sqrt_half(x[k])
    print()
    add_sign(x[k] & ~z[k] & Z)
    print()
    print("        cnf.vars.z[k] = Z")  
    print()

    #CNOT
    print("    def CNOT2CNF(cnf, c, t):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        X = cnf.add_var()")
    print("        cnf.vars.XVar.append(X)")
    to_py(	       Equivalent(X, x[t] ^ x[c]))
    print()
    print("        Z = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Z)")
    to_py(	       Equivalent(Z, z[t] ^ z[c]))
    print()
    add_sign(x[c] & z[t] & (~x[t] ^ z[c]))
    print()
    print("        cnf.vars.x[t] = X")
    print("        cnf.vars.z[c] = Z")
    print()
    
    #CZ
    Zc   = symbols('Zc')
    Zt   = symbols('Zt')
    print("    def CZ2CNF(cnf, c, t):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        Zc = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Zc)")
    to_py(	       Equivalent(Zc, z[c] ^ x[t]))
    print()
    print("        Zt = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Zt)")
    to_py(	       Equivalent(Zt, z[t] ^ x[c]))
    print()
    add_sign(x[t] & x[c] & (z[t] ^ z[c]))
    print()
    print("        cnf.vars.z[c] = Zc")
    print("        cnf.vars.z[t] = Zt")
    print()

    #CY
    Xt   = symbols('Xt')
    print("    def CY2CNF(cnf, c, t):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        Zc = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Zc)")
    to_py(	       Equivalent(Zc, z[c] ^ z[t] ^ x[t]))
    print()
    print("        Zt = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Zt)")
    to_py(	       Equivalent(Zt, z[t] ^ x[c]))
    print()
    print("        Xt = cnf.add_var()")
    print("        cnf.vars.XVar.append(Xt)")
    to_py(	       Equivalent(Xt, x[t] ^ x[c]))
    print()
    add_sign(x[c] & (x[t] ^ z[c]) & (x[t] ^ z[t]))
    print()
    print("        cnf.vars.z[c] = Zc")
    print("        cnf.vars.z[t] = Zt")
    print("        cnf.vars.x[t] = Xt")
    print()

    #SWAP
    print("    def SWAP2CNF(cnf, c, t):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        x[c], x[t] = x[t], x[c]")
    print("        z[c], z[t] = z[t], z[c]")
    print()

    #ISWAP
    print("    def ISWAP2CNF(cnf, c, t):")
    print("        pauli2cnf.SWAP2CNF(cnf, c, t)")
    print("        pauli2cnf.CZ2CNF(cnf, c, t)")
    print("        pauli2cnf.S2CNF(cnf, c)")
    print("        pauli2cnf.S2CNF(cnf, t)")
    print()

    #CS
    print("    def CS2CNF(cnf, c, t):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        Zc = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Zc)")
    to_py(	       x[c] | x[t] | Equivalent(Zc, z[c]))
    print()
    print("        Zt = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Zt)")
    to_py(	       x[c] | x[t] | Equivalent(Zt, z[t]))
    print()
    add_sign( (x[c] & z[c] & ~Zc) ^ (x[t] & z[t] & ~Zt) ^ ((~x[c] | ~x[t]) & (z[t] ^ Zt) & (z[c] ^ Zc) ))
    print()
    print("        u = cnf.add_var()")
    print("        cnf.vars.UVar.append(u)")
    print("        cnf.add_weight( u, Decimal(1/2))")
    print("        cnf.add_weight(-u, 1)")
    to_py(	       Equivalent(u, x[c] | x[t]))
    print()
    print("        cnf.vars.z[c] = Zc")
    print("        cnf.vars.z[t] = Zt")
    print()

    #CSdg
    print("    def CSdg2CNF(cnf, c, t):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        Zc = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Zc)")
    to_py(	       x[c] | x[t] | Equivalent(Zc, z[c]))
    print()
    print("        Zt = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Zt)")
    to_py(	       x[c] | x[t] | Equivalent(Zt, z[t]))
    print()
    add_sign( (x[c] & ~z[c] & Zc) ^ (x[t] & ~z[t] & Zt) ^ ((~x[c] | ~x[t]) & (z[t] ^ Zt) & (z[c] ^ Zc) ))
    print()
    print("        u = cnf.add_var()")
    print("        cnf.vars.UVar.append(u)")
    print("        cnf.add_weight( u, Decimal(1/2))")
    print("        cnf.add_weight(-u, 1)")
    to_py(	       Equivalent(u, x[c] | x[t]))
    print()
    print("        cnf.vars.z[c] = Zc")
    print("        cnf.vars.z[t] = Zt")
    print()

    # CâˆšX
    print("    def CSqrtX2CNF(cnf, c, t):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        Zc = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Zc)")
    to_py(	       x[c] | z[t] | Equivalent(Zc, z[c]))
    print()
    print("        Xt = cnf.add_var()")
    print("        cnf.vars.XVar.append(Xt)")
    to_py(	       x[c] | z[t] | Equivalent(Xt, x[t]))
    print()
    add_sign(   
                (x[c] & x[t] & Xt & z[c] & ~Zc) | 
                (Xt & z[c] & Zc & z[t] & ~x[t]) | 
                (x[c] & Xt & Zc & ~x[t] & ~z[c]) | 
                (x[t] & z[c] & z[t] & ~Xt & ~Zc) | 
                (x[c] & z[c] & ~x[t] & ~Xt & ~Zc) | 
                (Xt & z[t] & ~x[t] & ~z[c] & ~Zc) | 
                (x[c] & x[t] & Zc & ~Xt & ~z[c] & ~z[t]) | 
                (x[t] & Zc & z[t] & ~x[c] & ~Xt & ~z[c])
            )
    print()
    print("        u = cnf.add_var()")
    print("        cnf.vars.UVar.append(u)")
    print("        cnf.add_weight( u, Decimal(1/2))")
    print("        cnf.add_weight(-u, 1)")
    to_py(	       Equivalent(u, x[c] | z[t]))
    print()
    print("        cnf.vars.z[c] = Zc")
    print("        cnf.vars.x[t] = Xt")
    print()

    # CâˆšXdg
    print("    def CSqrtXdg2CNF(cnf, c, t):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        Zc = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Zc)")
    to_py(	       x[c] | z[t] | Equivalent(Zc, z[c]))
    print()
    print("        Xt = cnf.add_var()")
    print("        cnf.vars.XVar.append(Xt)")
    to_py(	       x[c] | z[t] | Equivalent(Xt, x[t]))
    print()
    add_sign(   
                (x[c] & x[t] & Xt & Zc & ~z[c]) | 
                (x[t] & z[c] & Zc & z[t] & ~Xt) | 
                (x[c] & x[t] & z[c] & ~Xt & ~Zc) | 
                (Xt & Zc & z[t] & ~x[t] & ~z[c]) | 
                (x[c] & Zc & ~x[t] & ~Xt & ~z[c]) | 
                (x[t] & z[t] & ~Xt & ~z[c] & ~Zc) | 
                (x[c] & Xt & z[c] & ~x[t] & ~Zc & ~z[t]) | 
                (Xt & z[c] & z[t] & ~x[c] & ~x[t] & ~Zc)
            )
    print()
    print("        u = cnf.add_var()")
    print("        cnf.vars.UVar.append(u)")
    print("        cnf.add_weight( u, Decimal(1/2))")
    print("        cnf.add_weight(-u, 1)")
    to_py(	       Equivalent(u, x[c] | z[t]))
    print()
    print("        cnf.vars.z[c] = Zc")
    print("        cnf.vars.x[t] = Xt")
    print()

    #CCX
    print("    def CCX2CNF(cnf, k, c, t):")
    # print("        pauli2cnf.CSqrtX2CNF(cnf, k, t)")
    # print("        pauli2cnf.CSqrtX2CNF(cnf, c, t)")
    # print("        pauli2cnf.CNOT2CNF(cnf, k, c)")
    # print("        pauli2cnf.CSqrtXdg2CNF(cnf, c, t)")
    # print("        pauli2cnf.CNOT2CNF(cnf, k, c)")
    # print()

    #RZ
    print("    def RZ2CNF(cnf, k, theta):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        Z = cnf.add_var()")
    print("        cnf.vars.ZVar.append(Z)")
    to_py(	       x[k] | Equivalent(Z, z[k]))
    print()
    print("        u1 = cnf.add_var()")
    print("        cnf.vars.UVar.append(u1)")
    print("        cnf.add_weight( u1, Decimal(math.cos(theta)))")
    print("        cnf.add_weight(-u1, 1)")
    to_py(	       Equivalent(u1, x[k] & (((z[k] & Z)) | (~z[k] & ~Z))))
    print()   
    print("        u2 = cnf.add_var()")
    print("        cnf.vars.UVar.append(u2)")
    print("        cnf.add_weight( u2, Decimal(math.sin(theta)))")
    print("        cnf.add_weight(-u2, 1)")
    to_py(	       Equivalent(u2, x[k] & (((~z[k] & Z)) | (z[k] & ~Z))))
    print()
    add_sign(x[k] & z[k] & ~Z)
    print()
    print("        cnf.vars.z[k] = Z")
    print()

    #RX
    print("    def RX2CNF(cnf, k, theta):")
    print("        x = cnf.vars.x")
    print("        z = cnf.vars.z")
    print()
    print("        X = cnf.add_var()")
    print("        cnf.vars.XVar.append(X)")
    to_py(	       z[k] | Equivalent(X, x[k]))
    print()   
    print("        u1 = cnf.add_var()")
    print("        cnf.vars.UVar.append(u1)")
    print("        cnf.add_weight( u1, Decimal(math.cos(theta)))")
    print("        cnf.add_weight(-u1, 1)")
    to_py(	       Equivalent(u1, z[k] & ((x[k] & X) | (~x[k] & ~X))))
    print()   
    print("        u2 = cnf.add_var()")
    print("        cnf.vars.UVar.append(u2)")
    print("        cnf.add_weight( u2, Decimal(math.sin(theta)))")
    print("        cnf.add_weight(-u2, 1)")
    to_py(	       Equivalent(u2, z[k] & ((~x[k] & X) | (x[k] & ~X))))
    print()
    add_sign(z[k] & ~x[k] & X)
    print()
    print("        cnf.vars.x[k] = X")
    print()
    print()
  
    # composiotion layer
    print('''
 
    def Composition(cnf, composition_dictionary):
        x, z = zip(*[(cnf.add_var(), cnf.add_var()) for _ in range(cnf.n)])
        weights = []
        sum_weights = 0
        for pauli_str, alpha in composition_dictionary["composition"].items():
            a = complex(alpha)
            if a == 0:
                continue
            a_r = a.real
            a_i = a.imag

            # pauli conditions
            conditions = []
            for i in range(len(pauli_str)):
                P = pauli_str[i]
                if P in ["I", "Z"]:
                    conditions.append(-x[i])
                else:
                    conditions.append( x[i])
                if P in ["I", "X"]:
                    conditions.append(-z[i])
                else:
                    conditions.append( z[i])

            # condition weight
            comp = cnf.add_var()
            wr = cnf.add_var()
            wi = cnf.add_var()
          
            if a_r != 0:
                cnf.add_weight(wr, a_r, comment=pauli_str)
                cnf.add_weight(-wr, 1)
                weights.append(wr)
                # w => pauli_str
                [cnf.add_clause([-wr, c]) for c in conditions]
                cnf.add_clause([-wr, -comp])
            if a_r == 0:
                cnf.add_clause([-wr])
                cnf.add_clause([comp])
          
            if a_i != 0:
                cnf.add_weight(wi, a_i, comment=pauli_str)
                cnf.add_weight(-wi, 1)
                weights.append(wi)
                # w => pauli_str
                [cnf.add_clause([-wi, c]) for c in conditions]
                cnf.add_clause([-wi, comp])
            if a_i == 0:
                cnf.add_clause([-wi])
                cnf.add_clause([-comp])
          
            sum_weights += abs(a)**2


        # [at least] one of the weights (more than one will lead to a contradiction of the conditions)
        cnf.add_clause(weights)
        # if sum_weights != 1:
        #     print(f'\\n\\tWARNNING: not normalized, sum of squared weights is {sum_weights}  ', end='')
        #     w = cnf.add_var()
        #     cnf.add_weight(w, str(Decimal(1/sum_weights).sqrt()), comment="normalize")
        #     cnf.add_weight(-w, 1)
        #     cnf.add_clause([w])
          
        return x,z,comp
    ''')

    print('''
    def Composition2CNF(cnf, composition_dictionary):
        assert composition_dictionary["qubits"] == cnf.n
        if cnf.n > 1:
          print("\\n Warning! For more than 1 quibit, composition has bugs!")
        lx, lz, lc = pauli2cnf.Composition(cnf, composition_dictionary)
        rx, rz, rc = pauli2cnf.Composition(cnf, composition_dictionary)
        x = cnf.vars.x
        z = cnf.vars.z
        Xs = [cnf.add_var() for _ in range(cnf.n)]
        Zs = [cnf.add_var() for _ in range(cnf.n)]
        print(Xs, Zs)
          
        # applying the conditions
        for k in range(cnf.n):
            X = Xs[k]
            Z = Zs[k]
    ''')
    lx = symbols('lx[k]')
    lz = symbols('lz[k]')
    rx = symbols('rx[k]')
    rz = symbols('rz[k]')

    to_py(Equivalent(X, lx^x[k]^rx), prefix="    ")
    to_py(Equivalent(Z, lz^z[k]^rz), prefix="    ")

    add_sign(And(Or((  lx & ~x[k] &  rx),
                    ( ~lx &  x[k] & ~rx),
                    (  lz & ~z[k] &  rz),
                    ( ~lz &  z[k] & ~rz)),
                 Or(lx, lz),
                 Or(x[k], z[k])), prefix="    ")
    
    to_py(Or(And(Equivalent(lx,x[k]),
                 Equivalent(lz,z[k])),
             And(Equivalent(rx,x[k]),
                 Equivalent(rz,z[k])),
             And(Equivalent(lx,rx),
                 Equivalent(lz,rz))    ), prefix="    ")
    
    rc = symbols('rc')
    lc = symbols('lc')
    to_py(Equivalent(rc, lc), prefix="")

    print(f'''
        cnf.vars.x = Xs
        cnf.vars.z = Zs
    ''')

    print()
    print()


    # Synthesis

    # dynamic single bit gate:

    idg   = symbols('idg[k]')
    hg    = symbols('hg[k]')
    sg    = symbols('sg[k]')
    tg    = symbols('tg[k]')
    tdg    = symbols('tdg[k]')

    Xk = symbols('X[k]')
    Zk = symbols('Z[k]')
    Rk = symbols('R[k]')
    Uk = symbols('U[k]')

    I_r = idg >> Equivalent(Rk, False)
    I_x = idg >> Equivalent(Xk, x[k])
    I_z = idg >> Equivalent(Zk, z[k])
    I_u = idg >> Equivalent(Uk, False)

    H_r = hg >> Equivalent(Rk, x[k] & z[k])
    H_x = hg >> Equivalent(Xk, z[k])
    H_z = hg >> Equivalent(Zk, x[k])
    H_u = hg >> Equivalent(Uk, False)

    S_r = sg >> Equivalent(Rk, x[k] & z[k])
    S_x = sg >> Equivalent(Xk, x[k])
    S_z = sg >> Equivalent(Zk, x[k] ^ z[k])
    S_u = sg >> Equivalent(Uk, False)

    T_r = tg >> Equivalent(Rk, x[k] & z[k] & ~Zk)
    Tdg_r = tdg >> Equivalent(Rk, x[k] & ~z[k] & Zk)
    T_x = (tg | tdg) >> Equivalent(Xk, x[k])
    T_z = (tg | tdg) >> Equivalent(Zk, z[k]) | x[k]
    T_u = (tg | tdg) >> Equivalent(Uk, x[k])

    single_qb_gate_properties = [I_r, I_x, I_z, I_u, H_r, H_x, H_z, H_u]
    #single_qb_gate_properties += [Tdg_r, T_r, T_x, T_z, T_u]
    #single_qb_gate_properties += [S_r, S_x, S_z, S_u]

    # dynamic two bit gate:

    cx_ct = symbols('cx[c][t]')
    Xc = symbols('X[c]')
    Xt = symbols('X[t]')
    Zc = symbols('Z[c]')
    Zt = symbols('Z[t]')
    Rc = symbols('R[c]')
    Rt = symbols('R[t]')
    Uc = symbols('U[c]')
    Ut = symbols('U[t]')

    CX_xc = cx_ct >> Equivalent(Xc, x[c])
    CX_xt = cx_ct >> Equivalent(Xt, x[t] ^ x[c])
    CX_zc = cx_ct >> Equivalent(Zc, z[t] ^ z[c])
    CX_zt = cx_ct >> Equivalent(Zt, z[t])
    CX_rc = cx_ct >> Equivalent(Rc, x[c] & z[t] & (~x[t] ^ z[c]))
    CX_rt = cx_ct >> Equivalent(Rt, False)
    CX_uc = cx_ct >> Equivalent(Uc, False)
    CX_ut = cx_ct >> Equivalent(Ut, False)

    cz_ct    = symbols('cz[c][t]')
    CZ_xc = cz_ct >> Equivalent(Xc, x[c])
    CZ_xt = cz_ct >> Equivalent(Xt, x[t])
    CZ_zc = cz_ct >> Equivalent(Zc, z[c] ^ x[t])
    CZ_zt = cz_ct >> Equivalent(Zt, z[t] ^ x[c])
    CZ_rc = cz_ct >> Equivalent(Rc, x[t] & x[c] & (z[t] ^ z[c]))
    CZ_rt = cz_ct >> Equivalent(Rt, False)
    CZ_uc = cz_ct >> Equivalent(Uc, False)
    CZ_ut = cz_ct >> Equivalent(Ut, False)

    csqrtx_ct    = symbols('csqrtx[c][t]')
    csqrtxdg_ct  = symbols('csqrtxdg[c][t]')
    # xc3 = xc0
    CSqrtX_xc = (csqrtx_ct | csqrtxdg_ct) >> Equivalent(Xc, x[c])
    # xt3 = xt0 or xc0 or zt0
    CSqrtX_xt = (csqrtx_ct | csqrtxdg_ct) >> Equivalent(Xt, x[t]) | x[c] | z[t]
    # zc3 = zc0 or xc0 or zt0
    CSqrtX_zc = (csqrtx_ct | csqrtxdg_ct) >> Equivalent(Zc, z[c]) | x[c] | z[t]
    # zt3 = zt0
    CSqrtX_zt = (csqrtx_ct | csqrtxdg_ct) >> Equivalent(Zt, z[t])
    # s3  = s0    ^ (xt0 and zt0) \
    #             ^ (xc0 and zc0 and (not (zc0 or xc0 or zt0))) \
    #             ^ (xt0 and zt0 and (not (xt0 or xc0 or zt0))) \
    #             ^ ((not xc0 or not zt0) and (xt0 ^ (xt0 or xc0 or zt0)) and (zc0 ^ (zc0 or xc0 or zt0))) \
    #             ^ (zt0 and (xt0 or xc0 or zt0))
    CSqrtX_rc   = csqrtx_ct >> Equivalent(Rc, 
                                          (x[t] and z[t]) \
                                        ^ (x[c] & z[c] & ~(z[c] | x[c] | z[t])) \
                                        ^ (x[t] & z[t] & ~(x[t] | x[c] | z[t])) \
                                        ^ ((~x[c] | ~z[t]) & (x[t] ^ (x[t] | x[c] | z[t])) & (z[c] ^ (z[c] | x[c] | z[t]))) \
                                        ^ (z[t] & (x[t] | x[c] | z[t]))
                                )
    CSqrtXdg_rc = csqrtxdg_ct >> Equivalent(Rc, 
                                              (x[t] and z[t]) \
                                            ^ (x[c] & ~z[c] & (z[c] | x[c] | z[t])) \
                                            ^ (x[t] & ~z[t] & (x[t] | x[c] | z[t])) \
                                            ^ ((~x[c] | ~z[t]) & (x[t] ^ (x[t] | x[c] | z[t])) & (z[c] ^ (z[c] | x[c] | z[t])))
                                            ^ (z[t] & (x[t] | x[c] | z[t]))
                                        )
    CSqrtX_rt = (csqrtx_ct | csqrtxdg_ct) >> Equivalent(Rt, False)
    CSqrtX_uc = (csqrtx_ct | csqrtxdg_ct) >> Equivalent(Uc, x[c] | x[t])
    CSqrtX_ut = (csqrtx_ct | csqrtxdg_ct) >> Equivalent(Ut, False)

    double_qb_gate_properties = [CX_xc, CX_xt, CX_zc, CX_zt, CX_rc, CX_rt, CX_uc, CX_ut]
    #double_qb_gate_properties += [CSqrtX_xc, CSqrtX_xt, CSqrtX_zc, CSqrtXdg_rc, CSqrtX_zt, CSqrtX_rc, CSqrtX_rt, CSqrtX_uc, CSqrtX_ut]
    # double_qb_gate_properties += [CZ_xc, CZ_xt, CZ_zc, CZ_zt, CZ_rc, CZ_rt, CZ_uc, CZ_ut]
    
    print('''
    def AMO(cnf, var_list):
        assert None not in var_list
        # at least one:
        cnf.add_clause(var_list)
        # at most one:
        [cnf.add_clause([-var_list[a],-var_list[b]]) for a in range(len(var_list)) for b in range(a+1, len(var_list))]
    ''')

    print()
    print()
    print('''
    def SynLayer2CNF(cnf, limit_gates=False, h_layer=False):
        n = cnf.n + cnf.ancillas
        x = cnf.vars.x
        z = cnf.vars.z
        X = [cnf.add_var() for _ in range(n)]
        Z = [cnf.add_var() for _ in range(n)]
          
        R = [cnf.add_var() for _ in range(n)]
        [cnf.add_weight(R[k], -1) for k in range(n)]
        [cnf.add_weight(-R[k], 1) for k in range(n)]
          
        if not limit_gates or not h_layer:
            U = [cnf.add_var() for _ in range(n)]
            [cnf.add_weight(U[k], str(Decimal(1/2).sqrt())) for k in range(n)]
            [cnf.add_weight(-U[k], 1) for k in range(n)]
        else:
            U = [0.5 for _ in range(n)]
          
        idg = [cnf.add_var(syn_gate_pick = True, Name = 'id', bits = [k]) for k in range(n)]
        if not limit_gates or h_layer:
            hg = [cnf.add_var(syn_gate_pick = True, Name = 'h', bits = [k]) for k in range(n)]
        else:
            hg = [0.5 for _ in range(n)]
        sg = [cnf.add_var(syn_gate_pick = True, Name = 's', bits = [k]) for k in range(n)]
        if not limit_gates or not h_layer:
            tdg = [cnf.add_var(syn_gate_pick = True, Name = 'tdg', bits = [k]) for k in range(n)]
            tg = [cnf.add_var(syn_gate_pick = True, Name = 't', bits = [k]) for k in range(n)]
            cx = [[cnf.add_var(syn_gate_pick = True, Name = 'cx', bits = [c,t]) if c!=t else None for t in range(n)] for c in range(n)]
            csqrtx = [[cnf.add_var(syn_gate_pick = True, Name = 'csqrtx', bits = [c,t]) if c!=t else None for t in range(n)] for c in range(n)]
            csqrtxdg = [[cnf.add_var(syn_gate_pick = True, Name = 'csqrtxdg', bits = [c,t]) if c!=t else None for t in range(n)] for c in range(n)]
        else:
            tdg = [0.5 for _ in range(n)]
            tg = [0.5 for _ in range(n)]
            cx = [[0.5 if c!=t else None for t in range(n)] for c in range(n)]
            csqrtx = [[0.5 if c!=t else None for t in range(n)] for c in range(n)]
            csqrtxdg = [[0.5 if c!=t else None for t in range(n)] for c in range(n)]
        for k in range(n):
    ''')
    for p in single_qb_gate_properties:
        to_py(p, prefix="    ")  
    print('''
            c = k
            for t in range(n):
                if t==c:
                    continue
    ''')
    for p in double_qb_gate_properties:
        to_py(p, prefix="        ") 
    print('''
            cxs_k = [cx[k][i] for i in range(n) if i!=k] + [cx[i][k] for i in range(n) if i!=k]
            #csqrtxs_k = [csqrtx[k][i] for i in range(n) if i!=k] + [csqrtx[i][k] for i in range(n) if i!=k]
            #csqrtxdgs_k = [csqrtxdg[k][i] for i in range(n) if i!=k] + [csqrtxdg[i][k] for i in range(n) if i!=k]
            gate_controlers = [idg[k]]
            if not limit_gates or h_layer:
                gate_controlers += [hg[k]]
            gate_controlers += [sg[k]]
            if not limit_gates or not h_layer:
                gate_controlers += [tdg[k], tg[k]]
                gate_controlers += cxs_k
               #gate_controlers += csqrtxs_k + csqrtxdgs_k
            pauli2cnf.AMO(cnf, gate_controlers)
          
            if cnf.syn_gate_layer>=2:
                # H -> !l_H
                cnf.add_clause([-hg[k],  -cnf.get_syn_var_past_layer(Name ='h', bit = k)])
                # T -> !l_Tdg
                cnf.add_clause([-tg[k],  -cnf.get_syn_var_past_layer(Name ='tdg', bit = k)])
                # Tdg -> !l_T
                cnf.add_clause([-tdg[k], -cnf.get_syn_var_past_layer(Name ='t', bit = k)])
                # I -> I until CX
                cnf.add_clause([-cnf.get_syn_var_past_layer(Name ='id', bit = k), idg[k]] + cxs_k)
          
            if cnf.syn_gate_layer>=5:
                # T -> !l_T | !ll_T | !lll_T | !llll_T
                cnf.add_clause([-tg[k]] + [-cnf.get_syn_var_past_layer(Name ='t', bit = k, past=p) for p in range(1, 5)])
                # Tdg -> !l_Tdg | !ll_Tdg | !lll_Tdg | !llll_Tdg
                cnf.add_clause([-tdg[k]] + [-cnf.get_syn_var_past_layer(Name ='tdg', bit = k, past=p) for p in range(1, 5)])

            c = k
            for t in range(n):
                if c!=t:
                    if cnf.syn_gate_layer>=2:
                        # CSqrtX(c,t) -> !past(CSqrtX(c,t))
                        # cnf.add_clause([-csqrtx[c][t], -cnf.get_syn_var_past_layer(Name ='csqrtx', bit = [c,t])])
                        # CX(c,t) -> !past(CX(c,t))
                        cnf.add_clause([-cx[c][t], -cnf.get_syn_var_past_layer(Name ='cx', bit = [c,t])])
                        # CX(c,t) -> !past(I(c)) or !past(I(t))
                        cnf.add_clause([-cx[c][t], -cnf.get_syn_var_past_layer(Name ='id', bit = c), -cnf.get_syn_var_past_layer(Name ='id', bit = t)])
        
                    if cnf.syn_gate_layer>=3:
                        # past(CX(c,t)) -> !past(past(T(c))) or !Tdg(c))
                        cnf.add_clause([-cnf.get_syn_var_past_layer(Name ='cx', bit = [c,t]), -cnf.get_syn_var_past_layer(Name ='tdg', bit = c, past=2), -tg[c]])
                        # past(CX(c,t)) -> !past(past(Tdg(c))) or !T(c))
                        cnf.add_clause([-cnf.get_syn_var_past_layer(Name ='cx', bit = [c,t]), -cnf.get_syn_var_past_layer(Name ='t', bit = c, past=2), -tdg[c]])
        
        cnf.vars.x[:n] = X
        cnf.vars.z[:n] = Z
    
    
    ''')



if __name__ == "__main__":
    main()
